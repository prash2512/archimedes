<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archimedes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@2.0.4"></script>
    <style>
        @keyframes pipe-flow {
            to { stroke-dashoffset: -24; }
        }
        .edge-flow {
            animation: pipe-flow 0.6s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- Top bar -->
    <header class="h-12 bg-gray-900 border-b border-gray-800 flex items-center px-4 gap-4">
        <span class="text-sm font-semibold tracking-wide">Archimedes</span>
        <button id="play-btn"
                class="w-8 h-8 flex items-center justify-center rounded bg-gray-800 hover:bg-gray-700 transition-colors"
                title="Play / Pause">
            <svg id="play-icon" class="w-4 h-4 text-green-400" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
            <svg id="pause-icon" class="w-4 h-4 text-yellow-400 hidden" viewBox="0 0 24 24" fill="currentColor"><rect x="5" y="3" width="4" height="18"/><rect x="15" y="3" width="4" height="18"/></svg>
        </button>
        <span class="text-xs text-gray-500">Tick <span id="tick-counter" class="text-gray-400 tabular-nums">0</span></span>
    </header>

    <div class="flex flex-1 overflow-hidden">

        <!-- Toolbox sidebar -->
        <aside class="w-56 bg-gray-900 border-r border-gray-800 p-3 flex flex-col gap-2 overflow-y-auto">
            <span class="text-xs text-gray-500 uppercase tracking-wider mb-1">Blocks</span>
            <div id="toolbox" hx-get="/api/blocks/html" hx-trigger="load" hx-swap="innerHTML">
            </div>

            <div class="border-t border-gray-800 pt-3 mt-3">
                <span class="text-xs text-gray-500 uppercase tracking-wider mb-2 block">Load</span>
                <label class="text-xs text-gray-400 flex justify-between">
                    <span>RPS</span>
                    <span id="rps-value">1,000</span>
                </label>
                <input type="range" id="rps-slider" min="0" max="100000" value="1000" step="100"
                       class="w-full mt-1 accent-blue-500">
            </div>
        </aside>

        <!-- Canvas -->
        <main id="canvas" class="flex-1 relative overflow-hidden"
              style="background-color: #030712; background-image: radial-gradient(circle, rgba(255,255,255,0.04) 1px, transparent 1px); background-size: 24px 24px;">
            <svg id="connections" class="absolute inset-0 w-full h-full" style="pointer-events: none;">
                <defs>
                    <marker id="arrow-blue" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#3b82f6" opacity="0.7" />
                    </marker>
                    <marker id="arrow-amber" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#f59e0b" opacity="0.7" />
                    </marker>
                    <marker id="arrow-red" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                        <polygon points="0 0, 8 3, 0 6" fill="#ef4444" opacity="0.7" />
                    </marker>
                </defs>
            </svg>
        </main>

    </div>

    <script>
    const canvas = document.getElementById('canvas');
    const svg = document.getElementById('connections');
    let nextId = 0;
    const edges = [];
    let selected = null;

    // Sidebar drag
    document.getElementById('toolbox').addEventListener('dragstart', (e) => {
        const block = e.target.closest('[data-kind]');
        if (!block) return;
        e.dataTransfer.setData('text/plain', JSON.stringify({
            kind: block.dataset.kind,
            name: block.dataset.name
        }));
    });

    canvas.addEventListener('dragover', (e) => e.preventDefault());

    canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        const rect = canvas.getBoundingClientRect();
        addBlock(data.kind, data.name, e.clientX - rect.left, e.clientY - rect.top);
    });

    // Click on canvas background deselects
    canvas.addEventListener('click', (e) => {
        if (e.target === canvas) deselect();
    });

    // Cmd/Ctrl+Z undoes the last connection
    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
            e.preventDefault();
            const edge = edges.pop();
            if (edge) { edge.pipe.remove(); edge.flow.remove(); }
        }
    });

    function addBlock(kind, name, x, y) {
        const el = document.createElement('div');
        el.id = 'block-' + (++nextId);
        el.dataset.kind = kind;
        el.className = 'absolute flex flex-col px-3 py-2 bg-gray-800 border border-gray-700 rounded text-sm select-none cursor-move hover:border-gray-500 transition-colors';
        el.style.left = (x - 60) + 'px';
        el.style.top = (y - 16) + 'px';
        el.innerHTML = `<div class="flex items-center gap-2"><img src="/static/icons/${kind}.svg" class="w-4 h-4 invert opacity-70"><span>${name}</span></div>`;
        el.addEventListener('mousedown', onMouseDown);
        canvas.appendChild(el);
    }

    // Combined drag + click: small moves are clicks, larger moves are drags
    function onMouseDown(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        const el = e.currentTarget;
        const startX = e.clientX, startY = e.clientY;
        const offsetX = e.clientX - el.offsetLeft;
        const offsetY = e.clientY - el.offsetTop;
        let dragged = false;

        function onMove(e) {
            if (!dragged && Math.abs(e.clientX - startX) < 4 && Math.abs(e.clientY - startY) < 4) return;
            dragged = true;
            el.style.left = (e.clientX - offsetX) + 'px';
            el.style.top = (e.clientY - offsetY) + 'px';
            updateEdges(el);
        }
        function onUp() {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            if (!dragged) handleClick(el);
        }
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    }

    function handleClick(el) {
        if (!selected) {
            selected = el;
            el.style.outline = '2px solid rgba(96, 165, 250, 0.6)';
            el.style.outlineOffset = '2px';
        } else if (selected === el) {
            deselect();
        } else {
            connect(selected, el);
            deselect();
        }
    }

    function deselect() {
        if (selected) {
            selected.style.outline = '';
            selected.style.outlineOffset = '';
        }
        selected = null;
    }

    function connect(from, to) {
        if (edges.some(e => e.from === from && e.to === to)) return;

        // Background pipe
        const pipe = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        pipe.setAttribute('stroke', '#3b82f6');
        pipe.setAttribute('stroke-width', '2');
        pipe.setAttribute('stroke-opacity', '0.15');
        pipe.setAttribute('stroke-linecap', 'round');

        // Animated flow layer
        const flow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        flow.setAttribute('stroke', '#3b82f6');
        flow.setAttribute('stroke-width', '2');
        flow.setAttribute('stroke-opacity', '0.8');
        flow.setAttribute('stroke-linecap', 'round');
        flow.setAttribute('stroke-dasharray', '6 18');
        flow.setAttribute('marker-end', 'url(#arrow-blue)');

        svg.appendChild(pipe);
        svg.appendChild(flow);
        const edge = { from, to, pipe, flow };
        edges.push(edge);
        drawEdge(edge);
    }

    function blockCenter(el) {
        return { x: el.offsetLeft + el.offsetWidth / 2, y: el.offsetTop + el.offsetHeight / 2 };
    }

    // Line endpoint at the block's rectangular border, not its center
    function edgePoint(center, target, hw, hh) {
        const dx = target.x - center.x, dy = target.y - center.y;
        if (dx === 0 && dy === 0) return { ...center };
        const scale = Math.min(hw / Math.abs(dx), hh / Math.abs(dy));
        return { x: center.x + dx * scale, y: center.y + dy * scale };
    }

    function drawEdge(edge) {
        const fc = blockCenter(edge.from), tc = blockCenter(edge.to);
        const a = edgePoint(fc, tc, edge.from.offsetWidth / 2, edge.from.offsetHeight / 2);
        const b = edgePoint(tc, fc, edge.to.offsetWidth / 2, edge.to.offsetHeight / 2);
        for (const el of [edge.pipe, edge.flow]) {
            el.setAttribute('x1', a.x); el.setAttribute('y1', a.y);
            el.setAttribute('x2', b.x); el.setAttribute('y2', b.y);
        }
    }

    function updateEdges(el) {
        for (const e of edges) {
            if (e.from === el || e.to === el) drawEdge(e);
        }
    }

    // RPS slider — live update while playing
    const rpsSlider = document.getElementById('rps-slider');
    const rpsValue = document.getElementById('rps-value');
    rpsSlider.addEventListener('input', () => {
        rpsValue.textContent = parseInt(rpsSlider.value).toLocaleString();
        if (playing) {
            fetch('/api/rps', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rps: parseInt(rpsSlider.value) })
            });
        }
    });

    // Play / Pause
    let playing = false;
    let evtSource = null;
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const tickCounter = document.getElementById('tick-counter');

    playBtn.addEventListener('click', () => {
        playing ? pause() : play();
    });

    function buildTopology() {
        const rps = parseInt(rpsSlider.value);
        const blockEls = canvas.querySelectorAll('[data-kind]');
        const topoBlocks = Array.from(blockEls).map(el => ({ id: el.id, kind: el.dataset.kind }));
        const topoEdges = edges.map(e => ({ from: e.from.id, to: e.to.id }));
        return { blocks: topoBlocks, edges: topoEdges, rps };
    }

    async function play() {
        if (evtSource) { evtSource.close(); evtSource = null; }
        const topo = buildTopology();
        if (topo.blocks.length === 0) return;
        const resp = await fetch('/api/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(topo)
        });
        if (!resp.ok) return;

        evtSource = new EventSource('/api/events');
        evtSource.onmessage = (e) => {
            const data = JSON.parse(e.data);
            tickCounter.textContent = data.tick;
            applyResults(data.blocks);
            applyEdgeResults(data.blocks);
            if (data.done) stopPlayback();
        };

        playing = true;
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
    }

    async function pause() {
        playing = false;
        pauseIcon.classList.add('hidden');
        playIcon.classList.remove('hidden');
        await fetch('/api/pause', { method: 'POST' });
        // EventSource stays open — drain animation plays until done:true
    }

    function stopPlayback() {
        if (evtSource) { evtSource.close(); evtSource = null; }
        playing = false;
        pauseIcon.classList.add('hidden');
        playIcon.classList.remove('hidden');
        clearEdgeResults();
    }

    const pipeColors = { green: '#3b82f6', yellow: '#f59e0b', red: '#ef4444' };
    const arrowIds = { green: 'arrow-blue', yellow: 'arrow-amber', red: 'arrow-red' };

    function applyEdgeResults(blockResults) {
        const byId = {};
        for (const b of blockResults) byId[b.id] = b;

        for (const edge of edges) {
            const src = byId[edge.from.id];
            const dst = byId[edge.to.id];
            if (!src) continue;

            const health = (dst && dst.health) || 'green';
            const color = pipeColors[health];
            const rps = dst ? dst.rps : (src.rps || 0);

            edge.pipe.setAttribute('stroke', color);
            edge.flow.setAttribute('stroke', color);
            edge.flow.setAttribute('marker-end', `url(#${arrowIds[health]})`);

            if (rps > 0) {
                edge.flow.classList.add('edge-flow');
                const speed = Math.max(0.15, 0.6 - (rps / 20000));
                edge.flow.style.animationDuration = speed + 's';
            } else {
                edge.flow.classList.remove('edge-flow');
            }
        }
    }

    function clearEdgeResults() {
        for (const edge of edges) {
            edge.pipe.setAttribute('stroke', '#3b82f6');
            edge.flow.setAttribute('stroke', '#3b82f6');
            edge.flow.setAttribute('marker-end', 'url(#arrow-blue)');
            edge.flow.classList.remove('edge-flow');
            edge.flow.style.animationDuration = '';
        }
    }

    const healthColors = {
        green: { border: 'border-green-500', text: 'text-green-400' },
        yellow: { border: 'border-yellow-500', text: 'text-yellow-400' },
        red: { border: 'border-red-500', text: 'text-red-400' },
    };

    function utilColor(v) {
        if (v < 0.6) return 'text-green-400';
        if (v < 0.9) return 'text-yellow-400';
        return 'text-red-400';
    }

    function applyResults(blockResults) {
        for (const b of blockResults) {
            const el = document.getElementById(b.id);
            if (!el) continue;

            el.classList.remove('border-gray-700', 'border-green-500', 'border-yellow-500', 'border-red-500');
            const colors = healthColors[b.health];
            el.classList.add(colors ? colors.border : 'border-gray-700');

            let row = el.querySelector('.util-row');
            if (!row) {
                row = document.createElement('div');
                row.className = 'util-row flex gap-2 text-xs mt-1';
                el.appendChild(row);
            }
            const metrics = [
                { label: 'CPU', val: b.cpu_util },
                { label: 'Mem', val: b.mem_util },
                { label: 'Disk', val: b.disk_util },
            ];
            row.innerHTML = metrics.map(m =>
                `<span class="${utilColor(m.val)}"><span class="text-gray-500">${m.label}</span> ${Math.round(m.val * 100)}%</span>`
            ).join('');

            let qRow = el.querySelector('.queue-row');
            if (b.queue_depth > 0.5) {
                if (!qRow) {
                    qRow = document.createElement('div');
                    qRow.className = 'queue-row text-xs mt-0.5';
                    el.appendChild(qRow);
                }
                qRow.innerHTML = `<span class="text-orange-400"><span class="text-gray-500">Queue</span> ${Math.round(b.queue_depth).toLocaleString()}</span>`;
            } else if (qRow) {
                qRow.remove();
            }
        }
    }
    </script>

</body>
</html>
